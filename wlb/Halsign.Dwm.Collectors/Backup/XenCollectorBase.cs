// Decompiled with JetBrains decompiler
// Type: Citrix.DWM.Collectors.XenCollectorBase
// Assembly: Citrix.Dwm.Collectors, Version=6.5.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 0844E477-F94E-4593-A883-69DEC5AD079C
// Assembly location: C:\Users\ShawnWang\Desktop\wlb\Citrix.Dwm.Collectors.dll

using Citrix.DWM.Domain;
using Citrix.DWM.Framework;
using CookComputing.XmlRpc;
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using XenAPI;

namespace Citrix.DWM.Collectors
{
  /// <summary>
  /// Data collector for Xen hypervisors
  /// 
  /// </summary>
  public abstract class XenCollectorBase : CollectorBase
  {
    private const int DefaultSessionTimeout = 20000;
    private const int DefaultSessionTimeoutRetryInterval = 30000;
    private const int DefaultSessionTimeoutMax = 60000;
    /// <summary>
    /// Handle to the pool master of the Xen pool that is being monitored.
    /// 
    /// </summary>
    protected Session _session;
    /// <summary>
    /// Handle for the event thread to the master of the Xen pool that is
    ///             being monitored.
    /// 
    /// </summary>
    protected Session _threadSession;
    /// <summary>
    /// The time, in milliseconds, to wait for a Xen session to respond
    ///             before reporting a timeout error.  This value is configured in
    ///             the wlb.conf file.
    /// 
    /// </summary>
    private int _sessionTimeout;
    /// <summary>
    /// The maximum time, in seconds, to which SessionTimeout can be set.
    ///             This value is configured in the wlb_config file.
    /// 
    /// </summary>
    private int _sessionTimeoutMax;
    /// <summary>
    /// The time, in milliseconds, to wait before trying to reconnect to
    ///             a Xen session to has failed with a timeout error.  This value is
    ///             configured in the wlb.conf file.
    /// 
    /// </summary>
    private int _sessionTimeoutRetryInterval;
    /// <summary>
    /// The number of consecutive XAPI calls that have timed out.
    /// 
    /// </summary>
    private int _sessionTimeoutCount;
    /// <summary>
    /// Flag to indicate if the data collector was stopped while it was
    ///             sleeping before retrying a Xen session following a timeout.
    /// 
    /// </summary>
    private bool _externalStop;
    /// <summary>
    /// DwmPool instance describing the hypervisor pool with which we
    ///             are interacting.
    /// 
    /// </summary>
    protected DwmPool _pool;
    /// <summary>
    /// If we lose the connection to the pool master we'll retry the
    ///             connection one time.  After that we have to assume the pool
    ///             master as gone down.
    /// 
    /// </summary>
    protected bool _retryLostConnection;
    /// <summary>
    /// ServerOpaqueRef of the pool master.  Used to heartbeat the
    ///             master to ensure it's alive and we have a valid connection.
    /// 
    /// </summary>
    protected string _masterServerOpaqueRef;
    /// <summary>
    /// Handle to the thread that is listening for Xen events that
    ///             are generated by the pool master.
    /// 
    /// </summary>
    protected Thread _eventThread;
    /// <summary>
    /// Hold the event that the main thread will use to signal the event
    ///             thread to stop.
    /// 
    /// </summary>
    protected WaitHandle[] _eventThreadWaitHandles;
    /// <summary>
    /// Will contain the list of Xen classes for which we would like to
    ///             receive events.
    /// 
    /// </summary>
    protected string[] _xenEventClasses;
    /// <summary>
    /// Flag to indicate if general tracing is enabled.
    /// 
    /// </summary>
    protected static bool _traceEnabled;
    /// <summary>
    /// Flag to indicate if tracing of metrics data is enabled.
    /// 
    /// </summary>
    protected static bool _traceEventsEnabled;

    /// <summary>
    /// Initialize a new instance of the XenCollectorBase.
    /// 
    /// </summary>
    public XenCollectorBase()
    {
      string[] strArray = new string[1];
      int index = 0;
      string str = "*";
      strArray[index] = str;
      this._xenEventClasses = strArray;
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    /// <summary>
    /// Initialize a new instance of the XenCollectorBase.
    /// 
    /// </summary>
    /// <param name="hostname">DNS name or TCP/IP address of a host in
    ///             a Xen pool from which data will be collected.</param><param name="port">TCP/IP port on which the host is listening for
    ///             requests.  The default is port 80.</param><param name="protocol">The protocol (http/https/etc) to used
    ///             when interacting with the pool master.</param><param name="username">User name to connect to the host.</param><param name="password">Password to connect to the host.</param>
    /// <remarks>
    /// The constructor will throw an DwmException if a session
    ///             cannot be established.
    /// </remarks>
    public XenCollectorBase(string hostname, int port, string protocol, string username, string password)
    {
      string[] strArray = new string[1];
      int index = 0;
      string str = "*";
      strArray[index] = str;
      this._xenEventClasses = strArray;
      // ISSUE: explicit constructor call
      base.\u002Ector();
      this.Initialize(hostname, port, protocol, username, password, 0);
    }

    /// <summary>
    /// Initialize this instance and create a new Xen session.
    /// 
    /// </summary>
    /// <param name="hostname">DNS name or TCP/IP address of a host in
    ///             a Xen pool from which data will be collected.</param><param name="port">TCP/IP port on which the host is listening for
    ///             requests.  The default is port 80.</param><param name="protocol">The protocol (http/https/etc) to used
    ///             when interacting with the pool master.</param><param name="username">User name to connect to the host.</param><param name="password">Password to connect to the host.</param><param name="poolId">The internal, database ID of the pool.  If
    ///             the database ID is not known, 0 can be specified.</param>
    /// <remarks>
    /// The constructor will throw an DwmException if a session
    ///             cannot be established.
    /// </remarks>
    public override void Initialize(string hostname, int port, string protocol, string username, string password, int poolId)
    {
      base.Initialize(hostname, port, protocol, username, password, poolId);
      this.InitializeSession();
    }

    /// <summary>
    /// Establish a session with a Xen host.
    /// 
    /// </summary>
    private void InitializeSession()
    {
      this.IsInitialized = false;
      int num = (int) this.InitializeSession(this._hostName, false, true);
      this.IsInitialized = true;
    }

    /// <summary>
    /// Attempt to establish a session with the specified Xen host.
    /// 
    /// </summary>
    /// <param name="hostName">Name or IP address of the host that is
    ///             believed to be the pool master.</param><param name="registerForEvents">Flag to indicate if the method
    ///             should register for Xen events</param><param name="rethrowExceptions">Flat to indicate if the method
    ///             should rethrow exceptions.</param>
    /// <returns>
    /// True if a session was successful established; false
    ///             otherwise.
    /// </returns>
    protected XenCollectorBase.SessionInitStatus InitializeSession(string hostName, bool registerForEvents, bool rethrowExceptions)
    {
      XenCollectorBase.SessionInitStatus sessionInitStatus1 = XenCollectorBase.SessionInitStatus.None;
      XenCollectorBase.SessionInitStatus sessionInitStatus2;
      try
      {
        this._sessionTimeout = Configuration.GetValueAsInt(ConfigItems.SessionTimeout);
        this._sessionTimeoutRetryInterval = Configuration.GetValueAsInt(ConfigItems.SessionTimeoutRetryInterval);
        this._sessionTimeoutMax = Configuration.GetValueAsInt(ConfigItems.SessionTimeoutMax);
        this._sessionTimeout = this._sessionTimeout <= 0 || this._sessionTimeout >= this._sessionTimeoutMax ? 20000 : this._sessionTimeout * 1000;
        this._sessionTimeoutMax = this._sessionTimeoutMax <= 0 || this._sessionTimeout >= this._sessionTimeoutMax ? 60000 : this._sessionTimeoutMax * 1000;
        this._sessionTimeoutRetryInterval = this._sessionTimeoutRetryInterval <= 0 || this._sessionTimeout >= this._sessionTimeoutMax ? 30000 : this._sessionTimeoutRetryInterval * 1000;
        this._sessionTimeout = this._sessionTimeout + 10 * this._sessionTimeoutCount * 1000;
        this._sessionTimeout = this._sessionTimeout >= this._sessionTimeoutMax ? this._sessionTimeoutMax : this._sessionTimeout;
        string fmt1 = "Data collection session timeout set to {0} seconds";
        object[] objArray1 = new object[1];
        int index1 = 0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local1 = (ValueType) (this._sessionTimeout / 1000);
        objArray1[index1] = (object) local1;
        Logger.Trace(fmt1, objArray1);
        string fmt2 = "Data collection session timeout max set to {0} seconds";
        object[] objArray2 = new object[1];
        int index2 = 0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local2 = (ValueType) (this._sessionTimeoutMax / 1000);
        objArray2[index2] = (object) local2;
        Logger.Trace(fmt2, objArray2);
        string fmt3 = "Data collection session timeout retry interval set to {0} seconds";
        object[] objArray3 = new object[1];
        int index3 = 0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local3 = (ValueType) (this._sessionTimeoutRetryInterval / 1000);
        objArray3[index3] = (object) local3;
        Logger.Trace(fmt3, objArray3);
        if (this._session != null)
          throw new InvalidOperationException("InitializeSession called and _session != null!");
        Session.UserAgent = "WlbDataCollector";
        this._session = new Session(this._sessionTimeout, hostName, this._hostPort);
        this._session.login_with_password(this._username, this._password);
        if (this._pool != null && this._pool.Id > 0)
          this._pool.AreCredentialsValid = true;
        else if (this._poolId > 0)
          new DwmPool(this._poolId).AreCredentialsValid = true;
        this._hostName = hostName;
        this._masterServerOpaqueRef = this._session.get_this_host();
        if (registerForEvents)
          this.RegisterForEvents();
        this._sessionTimeoutCount = 0;
        this._retryLostConnection = false;
        string fmt4 = "Started Xen session on {0}";
        object[] objArray4 = new object[1];
        int index4 = 0;
        string url = this._session.Url;
        objArray4[index4] = (object) url;
        Logger.Trace(fmt4, objArray4);
        sessionInitStatus2 = XenCollectorBase.SessionInitStatus.Success;
      }
      catch (Failure ex)
      {
        string fmt = "Failure exception {0} trying start session on {1}:{2}";
        object[] objArray = new object[3];
        int index1 = 0;
        string str1 = ex.ErrorDescription == null || ex.ErrorDescription.Count <= 0 ? ex.Message : ex.ErrorDescription[0];
        objArray[index1] = (object) str1;
        int index2 = 1;
        string str2 = hostName;
        objArray[index2] = (object) str2;
        int index3 = 2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) this._hostPort;
        objArray[index3] = (object) local;
        Logger.Trace(fmt, objArray);
        this.EndSession();
        if (Localization.Compare(ex.ErrorDescription[0], "HOST_IS_SLAVE", true) == 0)
          sessionInitStatus2 = XenCollectorBase.SessionInitStatus.HostIsSlave;
        else if (Localization.Compare(ex.ErrorDescription[0], "HOST_STILL_BOOTING", true) == 0)
          sessionInitStatus2 = XenCollectorBase.SessionInitStatus.HostStillBooting;
        else if (Localization.Compare(ex.ErrorDescription[0], "HOST_OFFLINE", true) == 0)
          sessionInitStatus2 = XenCollectorBase.SessionInitStatus.HostOffline;
        else if (Localization.Compare(ex.ErrorDescription[0], "SESSION_AUTHENTICATION_FAILED", true) == 0)
        {
          sessionInitStatus2 = XenCollectorBase.SessionInitStatus.AuthenticationFailure;
          if (this._pool != null && this._pool.Id > 0)
            this._pool.AreCredentialsValid = false;
          else if (this._poolId > 0)
            new DwmPool(this._poolId).AreCredentialsValid = false;
        }
        else
          sessionInitStatus2 = XenCollectorBase.SessionInitStatus.Failure;
        if (rethrowExceptions)
        {
          if (sessionInitStatus2 == XenCollectorBase.SessionInitStatus.HostIsSlave)
          {
            this.FindNewMaster();
            if (this._session != null)
              return sessionInitStatus1 = XenCollectorBase.SessionInitStatus.Success;
          }
          throw new DwmException(ex.Message, sessionInitStatus2 != XenCollectorBase.SessionInitStatus.AuthenticationFailure ? DwmErrorCode.XenCannotLogIn : DwmErrorCode.AuthenicationFailure, (Exception) ex);
        }
      }
      catch (SocketException ex)
      {
        string fmt = "SocketException exception {0} trying start session on {1}:{2}";
        object[] objArray = new object[3];
        int index1 = 0;
        string message = ex.Message;
        objArray[index1] = (object) message;
        int index2 = 1;
        string str = hostName;
        objArray[index2] = (object) str;
        int index3 = 2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) this._hostPort;
        objArray[index3] = (object) local;
        Logger.Trace(fmt, objArray);
        sessionInitStatus2 = XenCollectorBase.SessionInitStatus.SocketException;
        if (!rethrowExceptions)
        {
          this.OnConnectionLost((Exception) ex);
        }
        else
        {
          this.EndSession();
          throw new DwmException(ex.Message, DwmErrorCode.XenCannotLogIn, (Exception) ex);
        }
      }
      catch (WebException ex)
      {
        string fmt = "SocketException exception {0} trying start session on {1}:{2}";
        object[] objArray = new object[3];
        int index1 = 0;
        string message = ex.Message;
        objArray[index1] = (object) message;
        int index2 = 1;
        string str = hostName;
        objArray[index2] = (object) str;
        int index3 = 2;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) this._hostPort;
        objArray[index3] = (object) local;
        Logger.Trace(fmt, objArray);
        sessionInitStatus2 = XenCollectorBase.SessionInitStatus.WebException;
        if (!rethrowExceptions)
        {
          this.OnConnectionLost((Exception) ex);
        }
        else
        {
          this.EndSession();
          throw new DwmException(Localization.Format("Cannot connect to Xen {0}:{1} hypervisor.  The most likely causes include the machine being offline or an incorrect TCP/IP address.", (object) this._hostName, (object) this._hostPort), DwmErrorCode.XenCannotConnect, (Exception) ex);
        }
      }
      return sessionInitStatus2;
    }

    /// <summary>
    /// Close a data collector session.
    /// 
    /// </summary>
    /// 
    /// <remarks>
    /// If StartCollection and StopCollection are called, this
    ///             method does not need to be called.
    /// </remarks>
    public override void UnInitialize()
    {
      this.EndSession();
      base.UnInitialize();
    }

    /// <summary>
    /// Start collecting performance metrics for the Xen pool associated
    ///             with this instance.
    /// 
    /// </summary>
    public override void StartCollection()
    {
      base.StartCollection();
      this.RegisterForEvents();
    }

    /// <summary>
    /// Stop collecting performance metrics for the Xen pool associated
    ///             with this instance.
    /// 
    /// </summary>
    public override void StopCollection()
    {
      base.StopCollection();
      this.EndSession();
    }

    /// <summary>
    /// Register for interesting events (vm add, PDB detach, etc) within
    ///             the pool.
    /// 
    /// </summary>
    private void RegisterForEvents()
    {
      bool flag = true;
      try
      {
        this._threadSession = new Session(this._session, 86400000);
        Event.register(this._threadSession, this._xenEventClasses);
      }
      catch (Failure ex)
      {
        string fmt = "Threw exception {0} registering for Xen events";
        object[] objArray = new object[1];
        int index = 0;
        string message = ex.Message;
        objArray[index] = (object) message;
        Logger.Trace(fmt, objArray);
        Logger.LogException((Exception) ex);
        flag = false;
      }
      if (!flag)
        return;
      if (this._eventThreadWaitHandles == null)
      {
        this._eventThreadWaitHandles = new WaitHandle[1];
        this._eventThreadWaitHandles[0] = (WaitHandle) new AutoResetEvent(false);
      }
      else
        ((EventWaitHandle) this._eventThreadWaitHandles[0]).Reset();
      this._eventThread = new Thread(new ThreadStart(this.EventThreadProc));
      this._eventThread.Name = string.Format("XenCollectorEventThread(Pool {0})", (object) this._poolId);
      this._eventThread.IsBackground = true;
      this._eventThread.Start();
    }

    /// <summary>
    /// Remove registration entries for interesting events (vm add,
    ///             PDB detach, etc) within the pool.
    /// 
    /// </summary>
    private void UnregisterForEvents()
    {
      if (this._eventThread == null || this._eventThreadWaitHandles == null || this._eventThreadWaitHandles[0] == null)
        return;
      ((EventWaitHandle) this._eventThreadWaitHandles[0]).Set();
    }

    /// <summary>
    /// Listen for interesting events (vm add, PDB detach, etc) within the
    ///             pool.
    /// 
    /// </summary>
    private void EventThreadProc()
    {
      bool flag1 = false;
      string[] _classes = new string[this._xenEventClasses.Length];
      this._xenEventClasses.CopyTo((Array) _classes, 0);
      string fmt1 = "Handling events for {0}";
      object[] objArray1 = new object[1];
      int index1 = 0;
      string url = this._threadSession.Url;
      objArray1[index1] = (object) url;
      Logger.Trace(fmt1, objArray1);
      string _token = string.Empty;
      bool flag2 = false;
      while (!flag1)
      {
        try
        {
          XenCollectorBase._traceEventsEnabled = Configuration.GetValueAsBool(ConfigItems.DataEventTrace);
          if (WaitHandle.WaitAny(this._eventThreadWaitHandles, 1, false) == 0)
          {
            flag1 = true;
          }
          else
          {
            flag2 = this._threadSession.APIVersion <= API_Version.API_1_9;
            Proxy_Event[] proxyEventArray;
            if (flag2)
            {
              proxyEventArray = Event.next(this._threadSession);
            }
            else
            {
              Events events = Event.from(this._threadSession, _classes, _token, (double) this._sessionTimeout);
              _token = events.token;
              proxyEventArray = events.events;
            }
            for (int index2 = 0; index2 < proxyEventArray.Length; ++index2)
            {
              if (Localization.Compare(proxyEventArray[index2].class_, "host", true) == 0 || Localization.Compare(proxyEventArray[index2].class_, "vm", true) == 0 || (Localization.Compare(proxyEventArray[index2].class_, "pool", true) == 0 || Localization.Compare(proxyEventArray[index2].class_, "task", true) == 0))
              {
                int num = XenCollectorBase._traceEventsEnabled ? 1 : 0;
                string fmt2 = "XEN EVENT:  class: {0}   operation: {1}";
                object[] objArray2 = new object[2];
                int index3 = 0;
                string str1 = proxyEventArray[index2].class_;
                objArray2[index3] = (object) str1;
                int index4 = 1;
                string str2 = proxyEventArray[index2].operation;
                objArray2[index4] = (object) str2;
                XenCollectorBase.Trace(num != 0, fmt2, objArray2);
                object key = (object) "uuid";
                if (proxyEventArray[index2].snapshot != null)
                {
                  XmlRpcStruct snapshot = (XmlRpcStruct) proxyEventArray[index2].snapshot;
                  if (snapshot.ContainsKey(key))
                  {
                    string str3 = snapshot[key].ToString();
                    if (Localization.Compare(proxyEventArray[index2].class_, "host", true) == 0)
                      this.ProcessHostEvent(str3, proxyEventArray[index2].operation, proxyEventArray[index2].opaqueRef, snapshot);
                    else if (Localization.Compare(proxyEventArray[index2].class_, "pool", true) == 0)
                      this.ProcessPoolEvent(str3, proxyEventArray[index2].operation, proxyEventArray[index2].opaqueRef, snapshot);
                    else if (Localization.Compare(proxyEventArray[index2].class_, "vm", true) == 0)
                      this.ProcessVmEvent(str3, proxyEventArray[index2].operation, proxyEventArray[index2].opaqueRef, snapshot);
                    else if (Localization.Compare(proxyEventArray[index2].class_, "task", true) == 0)
                      this.ProcessTaskEvent(str3, proxyEventArray[index2].operation, proxyEventArray[index2].opaqueRef, snapshot);
                  }
                }
              }
            }
          }
        }
        catch (Failure ex)
        {
          string fmt2 = "Failure Exception in EventThreadProc for {0}";
          object[] objArray2 = new object[1];
          int index2 = 0;
          string str1 = this._threadSession == null ? "null session" : this._threadSession.Url;
          objArray2[index2] = (object) str1;
          Logger.Trace(fmt2, objArray2);
          string fmt3 = "EventThreadProc using event.{0} method.";
          object[] objArray3 = new object[1];
          int index3 = 0;
          string str2 = !flag2 ? "from" : "next";
          objArray3[index3] = (object) str2;
          Logger.Trace(fmt3, objArray3);
          Logger.LogException((Exception) ex);
          if (this.FailureToReason(ex) == CantBootReason.InvalidSession)
            break;
        }
        catch (IOException ex)
        {
          string fmt2 = "IOException in EventThreadProc for {0}";
          object[] objArray2 = new object[1];
          int index2 = 0;
          string str = this._threadSession == null ? "null session" : this._threadSession.Url;
          objArray2[index2] = (object) str;
          Logger.Trace(fmt2, objArray2);
          Logger.LogException((Exception) ex);
        }
        catch (SocketException ex)
        {
          string fmt2 = "SocketException in EventThreadProc for {0}";
          object[] objArray2 = new object[1];
          int index2 = 0;
          string str = this._threadSession == null ? "null session" : this._threadSession.Url;
          objArray2[index2] = (object) str;
          Logger.Trace(fmt2, objArray2);
          Logger.LogException((Exception) ex);
        }
        catch (WebException ex)
        {
          if (ex.Status == WebExceptionStatus.Timeout)
          {
            int num = XenCollectorBase._traceEventsEnabled ? 1 : 0;
            string fmt2 = "Timeout exception in EventThreadProc.  Session={0}";
            object[] objArray2 = new object[1];
            int index2 = 0;
            string str = this._threadSession == null ? "null session" : this._threadSession.Url;
            objArray2[index2] = (object) str;
            XenCollectorBase.Trace(num != 0, fmt2, objArray2);
          }
          else
          {
            string fmt2 = "WebException in EventThreadProc for {0}";
            object[] objArray2 = new object[1];
            int index2 = 0;
            string str = this._threadSession == null ? "null session" : this._threadSession.Url;
            objArray2[index2] = (object) str;
            Logger.Trace(fmt2, objArray2);
            Logger.LogException((Exception) ex);
          }
        }
        catch (ThreadAbortException ex1)
        {
          string fmt2 = "Caught expected ThreadAbortException for {0}";
          object[] objArray2 = new object[1];
          int index2 = 0;
          string str1 = this._threadSession == null ? "null session" : this._threadSession.Url;
          objArray2[index2] = (object) str1;
          Logger.Trace(fmt2, objArray2);
          string fmt3 = "No longer handling events for {0}";
          object[] objArray3 = new object[1];
          int index3 = 0;
          string str2 = this._threadSession == null ? "null session" : this._threadSession.Url;
          objArray3[index3] = (object) str2;
          Logger.Trace(fmt3, objArray3);
          if (this._threadSession != null)
          {
            try
            {
              this._threadSession.logout();
              string fmt4 = "Event thread session.logout {0} succeeds";
              object[] objArray4 = new object[1];
              int index4 = 0;
              string str3 = this._threadSession.Url == null ? string.Empty : this._threadSession.Url;
              objArray4[index4] = (object) str3;
              Logger.Trace(fmt4, objArray4);
            }
            catch (Exception ex2)
            {
              string fmt4 = "Event thread exception {0} calling _threadSession.logout";
              object[] objArray4 = new object[1];
              int index4 = 0;
              string message = ex2.Message;
              objArray4[index4] = (object) message;
              Logger.Trace(fmt4, objArray4);
            }
          }
          break;
        }
        catch (Exception ex)
        {
          Logger.LogException(ex);
        }
      }
      string fmt5 = "No longer handling events for {0}";
      object[] objArray5 = new object[1];
      int index5 = 0;
      string str4 = this._threadSession == null ? "null session" : this._threadSession.Url;
      objArray5[index5] = (object) str4;
      Logger.Trace(fmt5, objArray5);
      if (this._threadSession == null)
        return;
      try
      {
        this._threadSession.logout();
        string fmt2 = "Event thread session.logout {0} succeeds";
        object[] objArray2 = new object[1];
        int index2 = 0;
        string str1 = this._threadSession.Url == null ? string.Empty : this._threadSession.Url;
        objArray2[index2] = (object) str1;
        Logger.Trace(fmt2, objArray2);
      }
      catch (Exception ex)
      {
        string fmt2 = "Event thread exception {0} calling _threadSession.logout";
        object[] objArray2 = new object[1];
        int index2 = 0;
        string message = ex.Message;
        objArray2[index2] = (object) message;
        Logger.Trace(fmt2, objArray2);
      }
    }

    /// <summary>
    /// Process a Xen event of the specified VM
    /// 
    /// </summary>
    /// <param name="vmUuid">The unique ID of the VM that is the target of
    ///             the Xen event.</param><param name="operation">The event type - add, modify, etc.</param><param name="serverOpaqueRef">The server handle of the VM to which
    ///             the event applies.</param><param name="snapshot">The snapshot data associated with the
    ///             event.</param>
    protected abstract void ProcessVmEvent(string vmUuid, string operation, string serverOpaqueRef, XmlRpcStruct snapshot);

    /// <summary>
    /// Process a Xen event on the specified host
    /// 
    /// </summary>
    /// <param name="hostUuid">The unique ID of the host that is the target of
    ///             the Xen event.</param><param name="operation">The event type - add, modify, etc.</param><param name="serverOpaqueRef">The server handle of the Host to which
    ///             the event applies.</param><param name="snapshot">The snapshot data associated with the
    ///             event.</param>
    protected abstract void ProcessHostEvent(string hostUuid, string operation, string serverOpaqueRef, XmlRpcStruct snapshot);

    /// <summary>
    /// Process a Xen event of the specified task
    /// 
    /// </summary>
    /// <param name="taskUuid">The unique ID of the task that is the target of
    ///             the Xen event.</param><param name="operation">The event type - add, modify, etc.</param><param name="serverOpaqueRef">The server handle of the task to which
    ///             the event applies.</param><param name="snapshot">The snapshot data associated with the
    ///             event.</param>
    protected virtual void ProcessTaskEvent(string taskUuid, string operation, string serverOpaqueRef, XmlRpcStruct snapshot)
    {
    }

    /// <summary>
    /// Process a Xen event for the specified pool.
    /// 
    /// </summary>
    /// <param name="poolUuid">The unique ID of the pool that is the target
    ///             of the Xen event.</param><param name="operation">The event type - add, modify, etc.</param><param name="serverOpaqueRef">The server handle of the Pool to which
    ///             the event applies.</param><param name="snapshot">The snapshot data associated with the
    ///             event.</param>
    protected virtual void ProcessPoolEvent(string poolUuid, string operation, string serverOpaqueRef, XmlRpcStruct snapshot)
    {
    }

    /// <summary>
    /// Retrieve the specified property from the snapshot data that is
    ///             associated with a Xen event.
    /// 
    /// </summary>
    /// <param name="propName">Name of property to retrieve.</param><param name="snapshot">Snapshot of data associated with a Xen
    ///             event.</param><param name="propValue">On output, contains the value of the
    ///             property if it was present in the snapshot.  If the property
    ///             was not present in the snapshost, propValue will be null on
    ///             outpue.</param>
    /// <returns>
    /// True if the property was present in the snapshot;
    ///             false otherwise.
    /// </returns>
    protected bool GetProperty(string propName, XmlRpcStruct snapshot, out string propValue)
    {
      bool flag = true;
      object key = (object) propName;
      if (snapshot.ContainsKey(key))
      {
        propValue = snapshot[key].ToString();
      }
      else
      {
        propValue = (string) null;
        flag = false;
      }
      return flag;
    }

    /// <summary>
    /// Determine if the specified property within the snapshot data is
    ///             different from the old value.
    /// 
    /// </summary>
    /// <param name="propName">Name of property to check.</param><param name="snapshot">Snapshot of new values of all properties.</param><param name="oldValue">Old value of the property to check.</param>
    /// <returns>
    /// True if the property has changed; false otherwise
    /// </returns>
    protected bool HasPropertyChanged(string propName, XmlRpcStruct snapshot, string oldValue)
    {
      bool flag = false;
      object key = (object) propName;
      if (snapshot.ContainsKey(key) && Localization.Compare(snapshot[key].ToString(), oldValue, true) != 0)
        flag = true;
      return flag;
    }

    /// <summary>
    /// Determine if the specified property within the snapshot data is
    ///             different from the old value.
    /// 
    /// </summary>
    /// <param name="propName">Name of property to check.</param><param name="snapshot">Snapshot of new values of all properties.</param><param name="oldValue">Old value of the property to check.</param>
    /// <returns>
    /// True if the property has changed; false otherwise
    /// </returns>
    protected bool HasPropertyChanged<T>(string propName, XmlRpcStruct snapshot, List<XenRef<T>> oldValue) where T : XenObject<T>
    {
      bool flag = false;
      object key = (object) propName;
      if (snapshot.ContainsKey(key))
      {
        object[] objArray = (object[]) snapshot[key];
        if (objArray.Length == oldValue.Count)
        {
          for (int index = 0; index < objArray.Length; ++index)
          {
            if (Localization.Compare(objArray[index].ToString(), oldValue[index].opaque_ref, true) != 0)
            {
              flag = true;
              break;
            }
          }
        }
        else
          flag = true;
      }
      return flag;
    }

    /// <summary>
    /// Attempt to determine if a VM has completed a reboot by analyzing
    ///             the snapshot data of a VM event.
    /// 
    /// </summary>
    /// <param name="snapshot">&gt;The snapshot of VM that is associated with
    ///             the VM event.</param><param name="xenVM">The state of the VM prior to the event.</param>
    /// <returns>
    /// True if the VM has completed a reboot; false otherwise.
    /// 
    /// </returns>
    protected bool HasVmRebooted(XmlRpcStruct snapshot, VM xenVM)
    {
      bool flag = false;
      string propValue;
      int result;
      if (this.GetProperty("domid", snapshot, out propValue) && int.TryParse(propValue, out result))
      {
        object index = (object) "guest_metrics";
        string str = (string) snapshot[index];
        if (XenCollectorBase.IsValidXenRef(str))
        {
          if (XenCollectorBase.IsValidXenRef<VM_guest_metrics>(xenVM.guest_metrics))
          {
            if (string.Compare(str, xenVM.guest_metrics.opaque_ref, true) != 0)
              flag = true;
          }
          else
            flag = true;
        }
      }
      if (flag)
      {
        string fmt = "Refreshing cache for VM {0} ({1}) due to reboot.";
        object[] objArray = new object[2];
        int index1 = 0;
        string nameLabel = xenVM.name_label;
        objArray[index1] = (object) nameLabel;
        int index2 = 1;
        string uuid = xenVM.uuid;
        objArray[index2] = (object) uuid;
        Logger.Trace(fmt, objArray);
      }
      if (XenCollectorBase._traceEventsEnabled)
      {
        int num1 = XenCollectorBase._traceEventsEnabled ? 1 : 0;
        string fmt1 = "domid={0}";
        object[] objArray1 = new object[1];
        int index1 = 0;
        string str1 = (string) snapshot[(object) "domid"];
        objArray1[index1] = (object) str1;
        XenCollectorBase.Trace(num1 != 0, fmt1, objArray1);
        int num2 = XenCollectorBase._traceEventsEnabled ? 1 : 0;
        string fmt2 = "guest_metrics={0}";
        object[] objArray2 = new object[1];
        int index2 = 0;
        string str2 = (string) snapshot[(object) "guest_metrics"];
        objArray2[index2] = (object) str2;
        XenCollectorBase.Trace(num2 != 0, fmt2, objArray2);
      }
      return flag;
    }

    /// <summary>
    /// Trace the data associated with a XenServer virtual machine event.
    /// 
    /// </summary>
    /// <param name="snapshot">The VM data when the event fired.</param><param name="vm">The VM before the event fired.</param>
    protected static void TraceVmEvent(XmlRpcStruct snapshot, VM vm)
    {
    }

    /// <summary>
    /// Thread that does the actual data collection based on the poll
    ///             interval _pollInterval;
    /// 
    /// </summary>
    protected override void ThreadProc()
    {
      bool flag = false;
      if (this._session == null)
        return;
      string fmt1 = "Starting data collection for Xen Pool {0}.";
      object[] objArray1 = new object[1];
      int index1 = 0;
      string str1 = this._hostName;
      objArray1[index1] = (object) str1;
      Logger.Trace(fmt1, objArray1);
      while (!flag && !this._externalStop)
      {
        int num = this._pool == null || this._pool.IsLicensed ? this._pollInterval : this._noLicensePollInterval;
        switch (WaitHandle.WaitAny(this._waitHandles, this._pollInterval, false))
        {
          case 0:
            flag = true;
            continue;
          case 258:
            try
            {
              this.OnInterval();
              continue;
            }
            catch (Exception ex)
            {
              Logger.LogException(ex);
              continue;
            }
          default:
            continue;
        }
      }
      this.EndSession();
      string fmt2 = "Stopped data collection for Xen Pool {0}.";
      object[] objArray2 = new object[1];
      int index2 = 0;
      string str2 = this._hostName;
      objArray2[index2] = (object) str2;
      Logger.Trace(fmt2, objArray2);
    }

    /// <summary>
    /// Make sure the pool master is alive and we still have a valid
    ///             session.
    /// 
    /// </summary>
    /// 
    /// <returns>
    /// True if we have a valid session on the pool master;
    ///             false otherwise.
    /// </returns>
    protected bool Heartbeat()
    {
      try
      {
        if (this._session != null)
        {
          Host.get_servertime(this._session, this._masterServerOpaqueRef);
          this._retryLostConnection = false;
          this._sessionTimeoutCount = 0;
          return true;
        }
      }
      catch (Exception ex)
      {
        string fmt = "HEARTBEAT ({0}) - {1} Exception {2}";
        object[] objArray = new object[3];
        int index1 = 0;
        string url = this._session.Url;
        objArray[index1] = (object) url;
        int index2 = 1;
        string name = ex.GetType().Name;
        objArray[index2] = (object) name;
        int index3 = 2;
        string message = ex.Message;
        objArray[index3] = (object) message;
        Logger.Trace(fmt, objArray);
        this.OnConnectionLost(ex);
      }
      return false;
    }

    /// <summary>
    /// Handle the connection to the pool master being lost.  The first
    ///             time the connection is lost wwe just set a flag to retry on the
    ///             next poll interval.  If the connection is lost on two consecutive
    ///             poll intervals we will try to find a new pool master.
    /// 
    /// </summary>
    protected void OnConnectionLost(Exception e)
    {
      int num = this._sessionTimeoutRetryInterval;
      if (e == null)
      {
        ++this._sessionTimeoutCount;
        this._retryLostConnection = true;
      }
      else if (e is WebException)
      {
        if (((WebException) e).Status == WebExceptionStatus.Timeout)
        {
          ++this._sessionTimeoutCount;
          string fmt = "OnConnectionLost:  _sessionTimeoutCount={0}";
          object[] objArray = new object[1];
          int index = 0;
          // ISSUE: variable of a boxed type
          __Boxed<int> local = (ValueType) this._sessionTimeoutCount;
          objArray[index] = (object) local;
          Logger.Trace(fmt, objArray);
        }
      }
      else if (e is SocketException && ((SocketException) e).SocketErrorCode == SocketError.TimedOut)
      {
        ++this._sessionTimeoutCount;
        string fmt = "OnConnectionLost:  _sessionTimeoutCount={0}";
        object[] objArray = new object[1];
        int index = 0;
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) this._sessionTimeoutCount;
        objArray[index] = (object) local;
        Logger.Trace(fmt, objArray);
      }
      if (this._sessionTimeoutCount != 1 || this._retryLostConnection)
        this.EndSession();
      int millisecondsTimeout = this._sessionTimeoutCount <= 10 ? (this._sessionTimeoutCount <= 5 ? (this._sessionTimeoutCount <= 2 ? this._sessionTimeoutRetryInterval : 2 * this._sessionTimeoutRetryInterval) : 5 * this._sessionTimeoutRetryInterval) : 10 * this._sessionTimeoutRetryInterval;
      string fmt1 = "OnConnectionLost:  waiting={0} seconds before retrying";
      object[] objArray1 = new object[1];
      int index1 = 0;
      // ISSUE: variable of a boxed type
      __Boxed<int> local1 = (ValueType) (millisecondsTimeout / 1000);
      objArray1[index1] = (object) local1;
      Logger.Trace(fmt1, objArray1);
      switch (WaitHandle.WaitAny(this._waitHandles, millisecondsTimeout, false))
      {
        case 0:
          this._externalStop = true;
          break;
        case 258:
          if (this._retryLostConnection)
          {
            this._retryLostConnection = false;
            this.FindNewMaster();
            break;
          }
          this._retryLostConnection = true;
          break;
      }
    }

    /// <summary>
    /// End out current Xen session.
    /// 
    /// </summary>
    protected virtual void EndSession()
    {
      string fmt1 = "Ending session {0}";
      object[] objArray1 = new object[1];
      int index1 = 0;
      string str1 = this._session == null ? "null" : this._session.Url;
      objArray1[index1] = (object) str1;
      Logger.Trace(fmt1, objArray1);
      this.UnregisterForEvents();
      if (this._session == null)
        return;
      try
      {
        this._session.logout();
        string fmt2 = "session.logout {0} succeeds";
        object[] objArray2 = new object[1];
        int index2 = 0;
        string str2 = this._session.Url == null ? string.Empty : this._session.Url;
        objArray2[index2] = (object) str2;
        Logger.Trace(fmt2, objArray2);
      }
      catch (Exception ex)
      {
      }
      finally
      {
        this._session = (Session) null;
      }
      try
      {
        this._threadSession.logout();
        string fmt2 = "_threadSession.logout {0} succeeds";
        object[] objArray2 = new object[1];
        int index2 = 0;
        string str2 = this._session.Url == null ? string.Empty : this._session.Url;
        objArray2[index2] = (object) str2;
        Logger.Trace(fmt2, objArray2);
      }
      catch (Exception ex)
      {
      }
      finally
      {
        this._threadSession = (Session) null;
      }
    }

    /// <summary>
    /// Try to find a new pool master.
    /// 
    /// </summary>
    protected virtual void FindNewMaster()
    {
      Logger.Trace("Trying to find new pool master ...");
      if (this._poolId <= 0)
        return;
      DwmPool dwmPool = new DwmPool(this._poolId);
      dwmPool.Load();
      foreach (DwmHost dwmHost in (List<DwmHost>) dwmPool.Hosts)
      {
        string fmt1 = "  Trying {0} ...";
        object[] objArray1 = new object[1];
        int index1 = 0;
        string ipAddress = dwmHost.IPAddress;
        objArray1[index1] = (object) ipAddress;
        Logger.Trace(fmt1, objArray1);
        switch (this.InitializeSession(dwmHost.IPAddress, true, false))
        {
          case XenCollectorBase.SessionInitStatus.Success:
            return;
          case XenCollectorBase.SessionInitStatus.HostIsSlave:
            if (dwmPool.Hosts.Count == 1)
            {
              string fmt2 = "Deleting pool {0} ({1}) ({2}) because the last host has left the pool";
              object[] objArray2 = new object[3];
              int index2 = 0;
              string name = dwmPool.Name;
              objArray2[index2] = (object) name;
              int index3 = 1;
              // ISSUE: variable of a boxed type
              __Boxed<int> local = (ValueType) dwmPool.Id;
              objArray2[index3] = (object) local;
              int index4 = 2;
              string uuid = dwmPool.Uuid;
              objArray2[index4] = (object) uuid;
              Logger.Trace(fmt2, objArray2);
              dwmPool.Delete();
              continue;
            }
            continue;
          default:
            continue;
        }
      }
    }

    /// <summary>
    /// Handle a poll interval for the data collection thread querying
    ///             the hypervisor pool for performance metrics.
    /// 
    /// </summary>
    protected abstract void OnInterval();

    /// <summary>
    /// Determine if the specified XenRef instance is a valid reference.
    /// 
    /// </summary>
    /// <param name="xenRef">The XenRef instance to check.</param>
    /// <returns>
    /// True if the reference is valid; false otherwise.
    /// </returns>
    /// 
    /// <remarks>
    /// The reference is invalid if it is null, the ServerOpaqueRef
    ///             member is not null or empty string and the ServerOpaqueRef member is
    ///             not equal to 'OpaqueRef:NULL'
    /// </remarks>
    protected static bool IsValidXenRef<T>(XenRef<T> xenRef) where T : XenObject<T>
    {
      if (xenRef != null && !string.IsNullOrEmpty(xenRef.opaque_ref))
        return Localization.Compare(xenRef.opaque_ref, "OpaqueRef:NULL", true) != 0;
      return false;
    }

    /// <summary>
    /// Determine if the specified XenRef string is a valid reference.
    /// 
    /// </summary>
    /// <param name="serverOpaqueRef">The XenRef string instance to check.</param>
    /// <returns>
    /// True if the reference is valid; false otherwise.
    /// </returns>
    protected static bool IsValidXenRef(string serverOpaqueRef)
    {
      if (!string.IsNullOrEmpty(serverOpaqueRef))
        return Localization.Compare(serverOpaqueRef, "OpaqueRef:NULL", true) != 0;
      return false;
    }

    /// <summary>
    /// Convert a the ErrorDescription of a Xen exception into a
    ///             CantBootReason enumeration.
    /// 
    /// </summary>
    /// <param name="f">The Xen exception to convert.</param>
    /// <returns>
    /// CantBootReason representation of a Xen exception.
    /// </returns>
    protected CantBootReason FailureToReason(Failure f)
    {
      string s1 = f.ErrorDescription[0];
      return Localization.Compare(s1, "HANDLE_INVALID", true) != 0 ? (Localization.Compare(s1, "HA_NO_PLAN", true) != 0 ? (Localization.Compare(s1, "HA_OPERATION_WOULD_BREAK_FAILOVER_PLAN", true) != 0 ? (Localization.Compare(s1, "HOST_OFFLINE", true) != 0 ? (Localization.Compare(s1, "HOST_STILL_BOOTING", true) != 0 ? (Localization.Compare(s1, "INTERNAL_ERROR", true) != 0 ? (Localization.Compare(s1, "NO_HOSTS_AVAILABLE", true) != 0 ? (Localization.Compare(s1, "SESSION_AUTHENTICATION_FAILED", true) != 0 ? (Localization.Compare(s1, "SESSION_INVALID", true) != 0 ? (Localization.Compare(s1, "SR_HAS_NO_PBDS", true) != 0 ? (Localization.Compare(s1, "VM_BAD_POWER_STATE", true) != 0 ? (Localization.Compare(s1, "VM_REQUIRES_SR", true) != 0 ? (Localization.Compare(s1, "VM_REQUIRES_NETWORK", true) != 0 ? (Localization.Compare(s1, "VM_MISSING_PV_DRIVERS", true) != 0 ? (Localization.Compare(s1, "HOST_NOT_ENOUGH_FREE_MEMORY", true) != 0 ? (Localization.Compare(s1, "SR_BACKEND_FAILURE_72", true) != 0 ? (Localization.Compare(s1, "SR_BACKEND_FAILURE_140", true) != 0 ? (Localization.Compare(s1, "SR_BACKEND_FAILURE_222", true) != 0 ? (Localization.Compare(s1, "SR_BACKEND_FAILURE_225", true) != 0 ? CantBootReason.Unknown : CantBootReason.BackendFailure225) : CantBootReason.BackendFailure222) : CantBootReason.BackendFailure140) : CantBootReason.BackendFailure72) : CantBootReason.HostNotEnoughFreeMemory) : CantBootReason.VmMissingDrivers) : CantBootReason.VmRequiresNetwork) : CantBootReason.VmRequiresSr) : CantBootReason.VmBadPowerState) : CantBootReason.SrHasNoPbds) : CantBootReason.InvalidSession) : CantBootReason.AuthenticationFailure) : CantBootReason.NoHostAvailable) : CantBootReason.InternalError) : CantBootReason.HostStillBooting) : CantBootReason.HostOffline) : CantBootReason.HAOperationWouldBreakPlan) : CantBootReason.NoHAPlan) : CantBootReason.HandleInvalid;
    }

    /// <summary>
    /// Writes the text representation of the specified array of objects to
    ///             the log file if _traceEnabled is set to true.
    /// 
    /// </summary>
    /// <param name="traceFlag">If true, the message will be written.  If
    ///             false the message will be ignored.</param><param name="fmt">The format string.</param><param name="args">Objects to write using format.</param>
    protected static void Trace(bool traceFlag, string fmt, params object[] args)
    {
      if (!traceFlag)
        return;
      Logger.Trace(fmt, args);
    }

    /// <summary>
    /// The status code from attempting to create and initialize a new
    ///             XenServer session.
    /// 
    /// </summary>
    protected enum SessionInitStatus
    {
      None,
      Success,
      HostIsSlave,
      HostStillBooting,
      HostOffline,
      AuthenticationFailure,
      WebException,
      SocketException,
      Failure,
    }
  }
}
